---
layout: '@docsLayout'
title: 'Introduction'
description: ''
---

Signalize in a nutshell:
- Signalize is a client-side, JavaScript framework.
- There is a small 2 KB gzipped core, that contains an ES modules loader.
- This loader leaverages modern [import maps](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap).
- To use Signalize, setup the import map and initiate a new Signalize instance.
- Every time, you need some functionality, add necessary module keys into the import map and import them through the loader using `resolve` function.

The goal of this framework is to provide similar functionality modern frameworks like Vue, Svelte, Solid and Qwik has, but with minimum javascript, smallest possible learning curve, simple codebase, without dependencies and without the need of JavaScript backend.

## Playground
Signalize docs contains interactive examples. It's a great place to try Signalize. You can also use prepared [playground](/playground) that lets you share your code.

## Setup
In the simplified example bellow you can see Signalize initialization. Check it out / copy it and then go through each step bellow to understand, what this snippet does.
```html
<!-- 1. Configure the importmap -->
<script type="importmap">
	{
		"imports": {
			"signalizejs": "https://cdn.jsdelivr.net/npm/signalizejs@latest/+esm",
			"signalizejs/mutation-observer": "https://cdn.jsdelivr.net/npm/signalizejs@latest/+esm/mutation-observer"
			"signalizejs/event": "https://cdn.jsdelivr.net/npm/signalizejs@latest/+esm/event"
		}
	}
</script>
<script>
	// 2. Import the Signalize core
	import Signalize from 'signalizejs';

	// 3. Create a new Signalize instance
	const signalize = new Signalize();

	// 4.1 Resolve the Event module, because we need the "on" function
	// 4.2 The Event module will automatically import the Mutation Observer module
	const { on } = await signalize.resolve('event');

	// 5. Use the on function
	on('dom:ready', () => alert('Hello World!'));
</script>
```

A few notes to the simplified example:
- The Import map maps modules to public paths so we can import them.
- The Event module uses optimized observer for attaching listeners that doesn't affect [INP](https://web.dev/articles/inp).
- Imported modules are imported and inited only once and reused afterwards.

### 1. Install Signalize

#### NPM, Yarn, PNPM

To install Signalize locally, use NPM, Yarn or PNPM:
```bash
npm i signalizejs

yarn add signalizejs

pnpm i signalizejs
```

#### CDN
Signalize can also be used through CDN as a module. There is no IIFE or UMD export because ES modules are supported in all major browsers.
- For the production purpose, you might want to use exact version instead of the `latest` keyword
- It is also recommended to downlod and host the script on your own, to prevent CDN connection errors

```html
<script type="module">
	import Signalize from "https://cdn.jsdelivr.net/npm/signalizejs@latest/+esm"
</script>
```

### 2. Import Map Configuration
Signalize loader needs [import map](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap) to be configured, before it is used.

Import map script must always be placed before any javascript ES module import is triggerd.

You need to configure path for every module you or Signalize needs. If you don't want to update the import map every time you need a new functionality, you can copy the [complete import map](#complete-import-map) into your page and you will be ready to go:
- Official Signalize modules can be resolved using shortcuts like `event` and `signal`.
- However, during the request, the prefix `signalizejs` is added to prevent naming collisions so the requested module name is `signalizejs/event` and `signalizejs/signal` (this prefix can be changed by adding `instanceId` in the config during Signalize initialization).
- Because of this, you always need to configure `signalizejs` modules like `signalizejs/some-module`: `public path to module file`.

```html
<script type="importmap">
	{
		"imports": {
			"signalizejs/some-module": "public path to module"
		}
	}
</script>
```

### 3. Create a Signalize Instance
There can be several instances of Signalize on the same page. This can be usefull for example for external widgets configured differently than the rest of the page:
- Just keep in mind, they must be using different root and they cannot be nested.
- This means, if you have a global Signalize instance that is attached to `document element`, you cannot create another instance for the nested elements.
- You can however create another instance of Signalize for example for shadow root elements (custom Web Components) like widgets and such.
- Be aware, that global modules, like `SPA` for example, cannot be inited twice as there would be collision in the functionality.

```js
// global.js
import Signalize from 'signalizejs';

const signalize = new Signalize({
	// Optional - example with defaults
	root: document,
	instanceId: 'signalizejs',
	modules: [],
	params: {
		attributeSeparator: '-',
		attributePrefix: '',
	},
	globals: {}
});

// If you want global variable
window.signalize = signalize;
// Or :)
window.$ = signalize;

// Or if you prefer exports
export default signalize;
```

#### Configuration Options
| Option                 | Info                                                                                                                                                                                                                                                      |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **root**               | Optional. HTML Element \| Document. The root for which Signalize will be initialized.                                                                                                                                                                     |
| **params**             | Optional. Object. Used for configuration purposes. Values are accessed for example during module initialization. If `module name` exists as a `key` within the `params` then the value of the key is passed as a configuration to the module.             |
| **instanceId**         | Optional. String. This is used as a prefix during module import. Thanks to this you can configure different internal module versions like `signalizejs-next` in import map for different instances.                                                       |
| **modules**            | Optional. Array of modules and with configuration. Used for instant modules initialization. See bellow.                                                                                                                                                   |
| **globals**            | Optional. Object. Global variables. This is here, for variables you want have available within the Signalize instance. They are for example directly injected into directives by directives plugin.                                                       |

#### Default Params
| Key                    | Info                                                                                                                                                                                                                                                                                      |
|------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **attributeSeparator** | Optional. String. The separator used within all `attribute` selectors provided by modules. By default, the separator is `-` (dash). So you write for example `data-attribute`. If you set the separator to `:`, you will write `data:attribute`.                                          |
| **attributePrefix**    | Optional. String. The prefix before all "attribute" selectors provided by modules. By default you write `attribute=""`. If you want `data-` preefix (to have valid HTML for example), set the prefix and write `data-attribute=""`. This can be used to have valid attribute selectors.   |


### 4. Import What You Need
As mentioned in the import map section, official Signalize modules, can be imported without `signalizejs` prefix.
The naming of all additional modules you create or want to use is up to you.

Signalize modules can be imported in two ways:
- **Instantly**: Passed as modules during the initialization. Great for modules that we need immediately
- **Lazily** - Through the `resolve` function.

#### Instant Initialization
When you need some modules to be initialized immediately, pass them directly in the configuration.

All modules initialized this way, don't need to be added into the import map, because they are already resolved.

```js
import Signalize from 'signalizejs';
import myModule from './path/to/my/module.js';

const signalize = new Signalize({
	modules: [
		['my-module', myModule, { /* Direct Config - optional */ }]
	],
	params: {
		// This will be merged with by Direct Config
		// config = {...paramsConfig, ...directConfig}
		'my-module': { /* Params Config - optional */ }
	}
});

const { myFunction } = await signalize.resolve('my-module');
```

#### Lazy Initialization
Modules can also be loaded lazily using the `resolve` function.

This can decrease the amount of JavaScript on the page and improve the initialization time.

**Example with ES modules exports:**
```js
// page.js
import signalize from '/path/to/global.js';

const { myFunction } = await signalize.resolve('my-module');

// With direct config
// Every time you pass direct config while lazyloading a module,
// you will get a new instance of that module with merged configuration
// from params. This can be usefull to have one module on the page
// with different configuration.
const { myFunction } = await signalize.resolve([
	'my-module', { /* Direct Config */}
]);

// Loading several modules at once
const {
	moduleAFunction,
	moduleBFunction,
	moduleCFunction
} = await signalize.resolve(
	'moduleA',
	['moduleB', {/* Direct Config */}],
	'moduleC'
)
```

**Example with `window.signalize` variable:**
```js
// page.js
const { /* ... */ } = await window.signalize.resolve(/* ... */);
```

## Typescript & JSDOC Support
Because signalize `resolve` function can return literally anything, you need to set the return types dynamically based on what you import.

If you use bundlers, like Vite, Webpack or Rollup use `import type` instead of `import` because it would cause the the Signalize to be imported into multiple bunles.

### Typescript
If you use typescript, remember to always `import type` not the library itself (unless you need to load a module during the initialization as shown above).

```ts
import type { signalize } from 'global.js';
import type { on } from 'signalizejs/event';

const { on } = await signalize.resolve<{
	on: on
}>('event');
```

### JSDOC
```js
/**
 * @type {{
 * on: import('signalizejs/event').on
 * }}
 */
const { on } = await window.signalize.resolve('event');
```

In order to get the correct typehints for the global `signalize` variable in JSDOC, you need to define `global.d.ts` so the javascript can get correct types.

```ts
import type { Signalize } from "./packages/signalizejs/src/Signalize";

declare global {
	interface Window {
		signalize: Signalize
	}
}
```

## List of all Official Signalize Modules
Bellow is a list of all modules signalizejs provides.
 s
- ajax
- bind
- component
- dash-case, dialog, dom-ready, directives
- height, hyperscript
- intersection-observer, visibility
- mutation-observer
- scope, signal, snippets, spa
- task, traverse-dom
- viewport

## Complete Import Map
Bellow is a prepared snippet with all modules Signalize provides. You just need to a add public path to each module.

This way, you will not have to add internal dependencies into the import map every time you need a new functionality, because it will be already prepared.

```html
<script type="importmap">
	{
		"imports": {
			"signalizejs": "",
			"signalizejs/ajax": "",
			"signalizejs/bind": "",
			"signalizejs/component": "",
			"signalizejs/dash-case": "",
			"signalizejs/dialog": "",
			"signalizejs/directives": "",
			"signalizejs/dom-ready": "",
			"signalizejs/evaluate": "",
			"signalizejs/event": "",
			"signalizejs/height": "",
			"signalizejs/hyperscript": "",
			"signalizejs/intersection-observer": "",
			"signalizejs/visibility": "",
			"signalizejs/logger": "",
			"signalizejs/mutation-observer": "",
			"signalizejs/offset": "",
			"signalizejs/scope": "",
			"signalizejs/signal": "",
			"signalizejs/snippets": "",
			"signalizejs/spa": "",
			"signalizejs/task": "",
			"signalizejs/traverse-dom": "",
			"signalizejs/viewport": "",
			"signalizejs/width": ""
		}
	}
</script>
```

## Faster loading with modulepreload
If you want your modules to be loaded quickly, add [modulepreload](https://web.dev/articles/modulepreload) for each module in the importmap you know, that will be used immediately on the page.

Preload link elements must be placed before the first import map in the `head` element.

```html
<link rel="modulepreload" href="public module path">
```

## Why ES modules, Import Maps and Signalize loader?
Let's start with an example:
- You have a website, that has a layout, in which you have scripts used on the entire website.
- You also have a page, where you have scripts only for that particular page.
- When user loads the page, the layout and page scripts will be loaded.

The above scripts loading works fine until you encounter the following problems:
- What if our page has a component, its rendering depends on conditions. That component also loads scripts. We can load that script conditionally but what if there is another place on the same page in some nested component, that needs the same scripts? If such component loads its own bundle with the same dependency, we can end up with duplicated javascript on the same page. We can add the script directly into the page script but this brings new problems.
- If we have SPA architecture on our website, we can get duplicated scripts as well with the above approach.
- Also, what if we have some asynchronously lazyloaded chunk, that needs to have it's own dependencies? Again, the above solution is useless and things start to get complicated.

Problems mentioned above can be easily solved with import maps and ES modules:
- ES modules are imported only once and cached, you don't have to bundle them
- The dependencies problem will solve itself automatically because of imports+import map.
- For asynchronous loading, you can use dynamic [import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) function and top level awaits.

Now, if you decide to use ES modules and lazy load them, you will have to manually compose the entire initialization of the dependencies.
- This is solved automatically by Signalize loader.
- It automatically chains dependencies and initializes them with correct config.

### Trade offs
[ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) and [import maps](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap) have good support in browsers, however nothing is without trade-offs:
- In case, when you need to load a lot (like a hundred for example) uncached modules, it may be a bit slower than one big bundle.
- It is caused by the requests amount (and also, your users often doesn't have that performant devices like devs)
- You may want to test this, if this is your case
