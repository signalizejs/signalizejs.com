---
order: 2
layout: '@docsLayout'
title: 'signalizejs/component'
description: 'Create reusable web components with minimum effort.'
---

import Editor from '@codeEditor';
import ImportMapDependencies from '@components/DocsImportmapDependencies.astro';
import { createImportMapJson } from '@services/importmap.mjs';

## Installation
<ImportMapDependencies module="component" />

```js
const { component } = await signalize.resolve('component');
```

## API

## component
This function is used to define a new web component.

To define a web component, you must only call the `component` function with the name of the element. Any other argument, is optional.

The shortest defintion of web component can look like this:
```html
<script>
component('my-element');
</script>

<my-element />
```
This will register `my-element` custom element.

### Web Component options

Setup function receives the following arguments:
- `$el` - current component element
- `$` - current signalize instance
- `$refs` - returns an element or array of elements based on ref attribute: `$refs.field` => `<input ref="field">`.
- `$parent` - returns parent component `$parent()`. Can receive name of the parent like `$parent('custom-parrent')`.
- `$adopted` - Async, called in native web component adopted hook
- `$connected` - Async, called in native web component connected hook
- `$disconnected` - Async called in native web component disconnected hook

```js
component('my-element', {
	// Props as an array
	// All props are passed into $data and become publicly accessible
	// Every property becomes a Signal
	// Configured property names are passed into the observedAttributes field.
	// When property attribute value changes on an element, the new value is passed to the property signal
	// "some-prop" will be converted to camel case variable "someProp"
	props: ['some-prop'],
	props: {
		// key: default value
		someProp: ''
	},
	shadow: {
		// Native shadowRoot options
		// https://developer.mozilla.org/en-US/docs/Web/API/Web_components#api.shadowroot
	},
	// Right before component constructor exits
	setup({ $props, $el, $adopted, $connected, $disconnected }) {
		const { someProp } = $props;

		$adopted(() => {});
		$connected(() => {});
		$disconnected(() => {});

		return {  /* Public data added to prototype */ }
	},
})
```

<Editor code={`
<my-form>
	<form ref="form">
		<input ref="text">
		<button>First Form Submit</button>
	</form>
</my-form>

<br>

<my-form>
	<form ref="form">
		<input ref="text">
		<button>Second Form Submit</button>
	</form>
</my-form>

<script type="importmap">${createImportMapJson(['component'])}</script>

<script type="module">
import Signalize from 'signalizejs';

const { resolve } = new Signalize();
const { component } = await resolve('component');

// Because there are two scope="my-form"
// This defined scope will be inited twice
// for each matched element
component('my-form', {
	setup({ $refs, cleanup  }) {
		$refs.form.onsubmit = () => {
			alert($refs.text.value);
		}
	}
});
</script>
`} />

## Passing Properties to a Child Component
There are two ways to pass data to a child component:
- By using hooks.
- Or via directives - if you plan to use them.

### Hooks
Parent component can listen to an event that is fired, when child component is inited.

<Editor code={`
<parent-component>
	<p ref="output"></p>

	<child-component ref="child">
		<button ref="button">
			Increment: <span ref="count"></span>
		</button>
	</child-component>
</parent-component>

<script type="importmap">${createImportMapJson(['component', 'directives', 'signal', 'event', 'bind'])}</script>

<script type="module">
import Signalize from 'signalizejs';

const { resolve } = new Signalize();
const { component, signal, bind, on } = await resolve(
	'directives', 'component', 'signal', 'event', 'bind'
);

component('parent-component', ({ $refs }) => {
	const count = signal(1);

	on('component:setuped', $refs.child, ({ detail }) => {
		// 1. Pass initial value
		detail.count(count());

		// 2. Watch for child component signal change
		detail.count.watch(({ newValue }) => {
			count(newValue);
		});
	});

	bind($refs.output, { text: [count, () => \`Count affected from child: \${count}\`] });
});

component('child-component', {
	props: {
		count: 0
	},
	setup({ $props, $refs }) {
		const { count } = $props;
		on('click', $refs.button, () => count(count() + 1));
		bind($refs.count, { text: count });
	}
});
</script>
`} />


### Directives
If you decide to bind property throgh directives:
- Use `:property-name="js code"` like `:count="count"`.
- This way of passing properties uses two way data binding: child component can modify parent data.

<Editor code={`
<parent-component>
	<p :text="'Count affected from child:' + count"></p>

	<child-component :count="count">
		<button @click="count(count() + 1)">
			Increment: <span :text="count"></span>
		</button>
	</child-component>
</parent-component>

<script type="importmap">${createImportMapJson(['component', 'directives', 'signal'])}</script>

<script type="module">
import Signalize from 'signalizejs';

const { resolve } = new Signalize();
const { component, signal } = await resolve(
	'directives', 'component', 'signal'
);

component('parent-component', () => ({
	count: signal(1)
}));

component('child-component', {
	props: {
		count: 0
	}
});
</script>
`} />
